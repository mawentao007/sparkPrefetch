##v1
v1版本采用的预取调度策略是固定策略，即根据之前task的执行位置，将相应索引的task放到该位置。
这种方式可以适当提高命中率，但是比较死板，效果也不算太好，比之前随机分配好一点点.

存储的方式是存储到磁盘。

这个版本的效果不理想，有以下几个问题：

+   预取过程占用线程，影响当前任务执行
+   shuffle块文件太多，读写效率都很低
+   命中率太低
+   综上，预取的效果很不理想，不但没有促进系统反而造成了额外负担。

===

##v2
v2版本的目标是利用stage之间的空余事件片和IO完成预取，好处如下：

+   减少占用task正常执行，并且能利用到stage之间空余的大量资源；
+   因为执行的过程stage是空余的，因此可以实现100%命中；
+   预取过程可控，Stage开始之后未进行预取的任务自动丢弃。

执行过程:

1.  在executor有空余资源的时候，但是当前的task已经分配结束，这时候开启预调度过程，提前计算并根据局部性原则将下一阶段的数据推送到该节点；
2.  当一次预取结束后结果返回master并被记录，同时释放资源，用于下个阶段的执行或者数据预取；  
3.  当下一阶段的task执行时，会向master询问预取结果，如果有预取的数据在本地，则利用这些数据。

##v3
在v2的基础上,修改了调度方式,利用系统的getPreferLocation来预测下一阶段任务位置,并预取数据.通过这种方式命中率有大幅度提高,前提是代码中对部分rdd进行了cache.
cache之后预取的位置会更加准确.

##v4
之前的方式预取的数据都写入磁盘或者内存,效果不好,应该是因为读写磁盘的延迟+小文件数目多的原因.这个版本主要修改了预取数据的存储方式,buf不进行写,直接保存.任务开始的时候
将保存的预取数据放入结果队列即可.这样避免了读写磁盘,同时可以在任务开始的时候就有result结果可以获取.
需要注意的是处理好未使用的buf,选择合适的时机进行垃圾处理.